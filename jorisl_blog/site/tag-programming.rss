<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>JorisL blog</title><link>http://</link><description>My personal blog</description><pubDate>Mon, 14 Oct 2024 00:00:00 GMT</pubDate><lastBuildDate>Mon, 28 Jul 2025 12:10:42 GMT</lastBuildDate><generator>marmite</generator><item><title>Z3 intransitive dice</title><link>http:///z3-intransitive-dice.html</link><description><![CDATA["Using the Z3 theorem prover in Julia to generate 'rock-paper-scissor dice'."]]></description><category>programming</category><category>Julia</category><category>Z3</category><guid>http:///z3-intransitive-dice.html</guid><pubDate>Mon, 14 Oct 2024 00:00:00 GMT</pubDate><source url="http://">tag-programming</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p><a href="https://blog.jorisl.nl/media/z3_intransitive_dice/z3_intransitive_dice.html">Link to Jupyter notebook</a></p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Writing a simple lisp in LabVIEW and Nim</title><link>http:///writing-a-simple-lisp-in-labview-and-nim.html</link><description><![CDATA["Making my own programming language, first in LabVIEW and then in Nim."]]></description><category>programming</category><category>lisp</category><category>LabVIEW</category><category>Nim</category><guid>http:///writing-a-simple-lisp-in-labview-and-nim.html</guid><pubDate>Sun, 15 Jan 2023 00:00:00 GMT</pubDate><source url="http://">tag-programming</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p>Learning how to make an interpreter for a custom programming language was a challenge I wanted to do for quite some time.
Due to it's simplicity in parsing, and the number of resources available, it was a simple choice to make the custom language a lisp-like language.</p>
<h2><a href="#labview" aria-hidden="true" class="anchor" id="labview"></a>LabVIEW</h2>
<p><a href="https://github.com/JorisL/labview_lisp">The first version</a> of my custom interpreter was made in LabVIEW, for the following reasons:</p>
<ul>
<li>LabVIEW is often used at my job, but it had been a while since I programmed in it myself.
So I wanted to fresh up my knowledge.</li>
<li>There are lots of resources online, which I definitely needed to use, showing how to implement a lisp in a common language (Python, C, etc.).
Trying to implement it myself in LabVIEW, which uses a different paradigm than almost all other languages <sup class="footnote-ref"><a href="#fn-1" id="fnref-1" data-footnote-ref>1</a></sup>, forces me to actually understand what the examples show.</li>
<li>LabVIEW is arguably one of the worst (e.g. fun) languages suited for this kind of task.
And there are examples of people implementing a lisp in <a href="https://github.com/kanaka/mal">many languages</a>, I didn't yet see anyone who implemented something like this in LabVIEW.</li>
</ul>
<p>In this version of my programming language, I was eventually able to do things as defining functions and applying those functions to data.</p>
<pre><code class="language-lisp">(do
 ; get first element from a list
 (define first
   (lambda (x)
     (nth 0 x)))

 ; get remainder of list after first element
 (define rest
   (lambda (x)
     (nthrest 0 x)))

 ; insert element at the end of a list
 (define append
   (lambda (lst elt)
     (insert lst (len lst) elt)))

 ; apply return a list with func applied to each element of lst
 (define map
   (lambda (func lst)
     (do
       (define lstout (list))
       (while (not (= lst (list)))
         (do
           (define lstout (append lstout
                                  (func (first lst))))
           (define lst (rest lst))))
       lstout)))


  (map (lambda (x) (* x x))
      (list 1 2 3 4 5 6)))

; returns (1 4 9 16 25 36)

</code></pre>
<p>However, the implementation of this language needs a lot of recursion, and the number of recursive calls to VI's is severely limited.
Therefore the complexity of the program that can run are really limited.</p>
<h2><a href="#nim" aria-hidden="true" class="anchor" id="nim"></a>Nim</h2>
<p>After implementing an initial version in LabVIEW, I wanted to make an interpreter that would actually be capable of running 'something'.
For <a href="https://github.com/JorisL/nim_lisp">this implementation</a> I'd chosen <a href="https://nim-lang.org">Nim</a>, as it is a relatively high-level, but still quick and compiled, language.
This project was a good way of trying out the language.</p>
<p>In this version of the language I was able to add some additional functionalities, such as Macro support.
Using lisp macro's you are able to add features and structures to the language that can't be implemented as a function during execution.
See the snippet below from the 'standard library'; In the Nim interpreter I did not define how it should handle an <code>and</code> or <code>or</code> keyword,
and these cannot be implemented as functions<sup class="footnote-ref"><a href="#fn-2" id="fnref-2" data-footnote-ref>2</a></sup>.
But using macro's it is possible to define how these can be rewritten as, in this case, an if statement (which in turn is also defined as a macro).</p>
<pre><code class="language-lisp"> (define and
   (macro
    (a b)
    (quasiquote
     (if (unquote a) (unquote b) nil))))

 (define or
   (macro
    (a b)
    (quasiquote
     (if (unquote a) (unquote a) (unquote b)))))
</code></pre>
<p>In order to test that my programming language could actually do 'something', I <a href="https://github.com/JorisL/nim_lisp/blob/main/examples/bf/brainfuck.nlisp">implemented another programming language in it</a>.
Note that efficiency was not the main goal of this project ðŸ˜„<sup class="footnote-ref"><a href="#fn-3" id="fnref-3" data-footnote-ref>3</a></sup>.</p>
<hr />
<!-- Content Injected to every content markdown footer -->
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-1">
<p>LabVIEW uses the dataflow programming paradigm, while most languages are instead of procedural, functional, and/or object oriented. <a href="#fnref-1" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="1" aria-label="Back to reference 1">â†©</a></p>
</li>
<li id="fn-2">
<p>A function always evaluates it's arguments. For example <code>(+ 2 (* 6 7))</code> first evaluates to <code>(+ 2 42)</code>.
But in, for example, an <code>and</code> statement, you only want the 2nd argument to be evaluated if the first argument is true.
Therefore it is not possible to implement an <code>and</code> statement, among others, as a function. <a href="#fnref-2" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="2" aria-label="Back to reference 2">â†©</a></p>
</li>
<li id="fn-3">
<p>Eventually I ran a brainfuck interpreter in my brainfuck interpreter in my lisp, and used that to run a brainfuck hello world program.
That one took around 24 hours to run. <a href="#fnref-3" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="3" aria-label="Back to reference 3">â†©</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>Helix, Python, and Poetry</title><link>http:///helix-python-and-poetry.html</link><description><![CDATA["Setting up the Helix editor and python-lsp-server for poetry projects."]]></description><category>programming</category><category>python</category><category>helix</category><guid>http:///helix-python-and-poetry.html</guid><pubDate>Sat, 05 Nov 2022 00:00:00 GMT</pubDate><source url="http://">tag-programming</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<h2><a href="#tldr" aria-hidden="true" class="anchor" id="tldr"></a>TL;DR</h2>
<ul>
<li>Set up poetry to store its virtual environment within the project root.</li>
<li>Install <code>python-lsp-server</code> and <code>black</code> within the virtual environment.</li>
<li>Open a terminal session with that virtual environment enabled
(<code>.venv/Scripts/Activate</code>).</li>
<li>Start the helix editor within that terminal session.</li>
</ul>
<h2><a href="#introduction" aria-hidden="true" class="anchor" id="introduction"></a>Introduction</h2>
<p>At work I've been developing several small-ish software projects in Python using
<a href="https://python-poetry.org">poetry</a> to manage the different dependencies,
virtual environments, etc. for each of those projects. So far I've mostly been
using Visual Studio Code to edit these projects, instead of using my old and
trusted <a href="https://github.com/JorisL/.emacs.d">Emacs config</a>.</p>
<p>The main reason for using VS Code was due to difficulties with Emacs to get the
Python language server protocol correctly working for those projects. It <em>was</em>
quite easy to install and set-up the python-lsp-server with emacs for projects
using the main installed Python installation on my PC, but each of these
projects had their own python virtual environment with various packages either
not installed or with a different version of my &quot;main&quot; Python installation. This
caused problems with the LSP server, where it would state multiple errors in my
code due to it not being able to find the various packages and libraries used in
those projects. With VS Code this wasn't a problem, since it was relatively easy
to select either the main Python installation on my PC or the Python
installation within the poetry virtual environment.</p>
<p>In principle this setup worked for development, but I wasn't entirely happy
using it. The editor I mostly used outside of this project was Emacs, which I
already set up with a modal editing mode slightly based on
<a href="https://kakoune.org">Kakoune</a>. While there <em>are</em> several extentions for VS code
to add a modal editing mode, they where never really a joy to use. Mostly due to
sluggishness and it still feeling like a &quot;hack&quot; on top of a non-modal editor,
instead of it beging an integraded experience. Furthermore several
functionalities I see as being essential to have in an editor, such as macros,
are not available in VS Code.</p>
<p>Lately I've been trying out the <a href="https://helix-editor.com">Helix</a> editor, and so
far it has been a joy to use. It is a lightweight, modal, terminal text editor,
similar to VIM. But where with VIM you practically need to install mutliple
additional packages to make it sort-of usable for day-to-day use (LSP, FZF,
surround, etc.), Helix already has most of these functions build-in. And since
the editor is build with those integrations from the ground up it is quite a lot
easier and straightforward to use. And the default keybindings are, in my
opinion, a lot easier to remember and use as those from VIM. Most of the things
I also did with Emacs seem to be relatively easy to do with Helix (with some
small tweaks, such as using markdown for notes instead of org mode).</p>
<p>So, in order to try and transfer my workflow to Helix, I've been trying to set
it up with both
<a href="https://github.com/python-lsp/python-lsp-server">python-lsp-server</a> and poetry,
and it seems I've found a workable solution for my use-case.</p>
<h2><a href="#how-to-configure-the-tools" aria-hidden="true" class="anchor" id="how-to-configure-the-tools"></a>How to configure the tools</h2>
<h3><a href="#poetry-local-venv-directory" aria-hidden="true" class="anchor" id="poetry-local-venv-directory"></a>Poetry local .venv directory</h3>
<p>Each poetry project always gets a seperate directory for storing it's Python
virtual environment. Thanks to this each project can have different versions of
Python and libraries installed without clashing with each other. By default a
directory is made in the <code>{cache-dir}/virtualenvs</code> of your PC, but poetry can
(and for this trick, should) also be set up to store the virtual-environment
data from a project within a .venv folder in the project root.</p>
<p>This is done by setting the <code>virtualenvs.in-project</code> within the
<a href="https://python-poetry.org/docs/configuration/#virtualenvsin-project">poetry configuration</a>
to <code>true</code>.</p>
<h3><a href="#activating-the-virtual-environment" aria-hidden="true" class="anchor" id="activating-the-virtual-environment"></a>Activating the virtual environment</h3>
<p>The .venv folder created within the project root contains scripts in order to
activate the virtual environment. See
<a href="https://docs.python.org/3/library/venv.html#how-venvs-work">this</a> section in
the Python documentation. Within Windows this can be activated by first opening
a powershell terminal within the project root and then running
<code>.venv\Scripts\Activate.ps1</code>. Now, for as long as this terminal is open, the
paths to Python and other related binaries and scripts are changed to those kept
in the .venv directory. Note that this only counts when running commands within
that powershell session. Opening a new powershell terminal parallel to this one,
then running Python from that one will use the standard system Python binary.</p>
<h3><a href="#installing-python-lsp-server-and-other-tools-within-the-virtual-environment" aria-hidden="true" class="anchor" id="installing-python-lsp-server-and-other-tools-within-the-virtual-environment"></a>Installing python-lsp-server and other tools within the virtual environment</h3>
<p>The trick to using LSP with Helix with a poetry project is to run Helix within
the powershell terminal after enabling the project's virtual environment. This
way, when the Helix process calls tools like <code>python-lsp-server</code> it will use the
Python installation as used in the poetry project. Therefore the LSP server also
correctly scans the project files with the python packages actually used in the
project.</p>
<p>But for this to work we now have to install <code>python-lsp-server</code> within the
project's virtual environment. The same counts for tools like <code>black</code>. Whilst in
the terminal with the virtual environment this can quickly be done using
<code>pip install python-lsp-server black</code>, but a better way would be to set up these
packages as requirements within the project's <code>pyproject.toml</code> file.</p>
<h3><a href="#setting-up-helix" aria-hidden="true" class="anchor" id="setting-up-helix"></a>Setting up Helix</h3>
<p>Configure the <code>languages.toml</code> file withing the Helix configuration directory
(<code>./config/helix/</code> or <code>%AppData%\\Roaming\\helix</code>) to use <code>pylsp</code> as the
language server (and if wanted <code>black</code> to be the code formatter), and make sure
to <strong>not</strong> use hard coded file paths for these. Otherwise when hard coded paths
are used it will not use the .venv versions when needed.</p>
<p>An example of this is shown below<sup class="footnote-ref"><a href="#fn-1" id="fnref-1" data-footnote-ref>1</a></sup><sup class="footnote-ref"><a href="#fn-2" id="fnref-2" data-footnote-ref>2</a></sup>:</p>
<pre><code class="language-{.toml">[[language]]
name = &quot;python&quot;
language-server = { command = &quot;pylsp&quot; }
formatter = { command = &quot;black&quot;, args = [&quot;--quiet&quot;, &quot;-&quot;] }
auto-format = true
</code></pre>
<p>including settings to set a max. line length for both formatting and linting.</p>
<p>settings, for example max. line lengths, since these are not read from the
poetry's <code>pyproject.toml</code> configuration file. According to the Helix
documentation it should be possible to include a <code>languages.toml</code> settings file
like above within a project, such that you can have different settings LSP or
formatter settings for different projects, but I've not tested that yet.</p>
<h3><a href="#testing-the-configuration" aria-hidden="true" class="anchor" id="testing-the-configuration"></a>Testing the configuration</h3>
<p>Helix has a startup option to check if the tools for a certain language are
correctly set up: <code>hx --health &lt;language&gt;</code>. When we open a new terminal window
and run this command with python as our language we should get something like
this:</p>
<pre><code>$ hx --health python
Configured language server: pylsp
Binary for language server: /opt/homebrew/bin/pylsp
Configured debug adapter: None
Highlight queries: âœ“
Textobject queries: âœ“
Indent queries: âœ˜
</code></pre>
<p>In this case the found language server binary is the one from our system Python
installation. But when this same command is executed from a terminal with the
virtual environment enabled we should see this path change to something like
<code>.venv/Scripts/pylsp</code>.</p>
<h2><a href="#usage" aria-hidden="true" class="anchor" id="usage"></a>Usage</h2>
<p>Now, when we want to edit files from the given poetry project we need to start a
terminal in the root folder of the poetry project, and then enable the virtual
environment. If we then run <code>hx</code> within that terminal<sup class="footnote-ref"><a href="#fn-3" id="fnref-3" data-footnote-ref>3</a></sup> it will use the
project's pylsp server instead of the system's pylsp server.</p>
<p>directory of Helix is now the project's working directory. Now commands like
<code>&lt;space&gt; f</code> will only search for files within the project.</p>
<p>To make things a bit easier we can make a script or terminal configuration to
open a terminal in the project's directory and automatically enable the virtual
environment. Within, for example, Windows Terminal, this can be done by creating
a new powershell configuration with the project's root as startup path and the
followin line as startup command:</p>
<pre><code>powershell -noexit .venv/Scripts/Activate.ps1
</code></pre>
<p>Now you can just start this configuration, run <code>hx</code>, and start editing. And a
2nd terminal with this configuration can be opened to run and debug the python
code.</p>
<!-- Content Injected to every content markdown footer -->
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-1">
<p>see <a href="https://github.com/JorisL/helix">https://github.com/JorisL/helix</a> for my latest configuration, <a href="#fnref-1" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="1" aria-label="Back to reference 1">â†©</a></p>
</li>
<li id="fn-2">
<p>This is where we also must configure some LSP and formatter related <a href="#fnref-2" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="2" aria-label="Back to reference 2">â†©</a></p>
</li>
<li id="fn-3">
<p>An added benefit of running hx within this terminal is that the working <a href="#fnref-3" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="3" aria-label="Back to reference 3">â†©</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>Generating juggling siteswaps</title><link>http:///generating-juggling-siteswaps.html</link><description><![CDATA["Generating juggling patterns in Julia using graph theory."]]></description><category>programming</category><category>Julia</category><category>juggling</category><guid>http:///generating-juggling-siteswaps.html</guid><pubDate>Tue, 01 Mar 2022 00:00:00 GMT</pubDate><source url="http://">tag-programming</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p><a href="https://blog.jorisl.nl/media/siteswaps_julia/siteswaps_julia.html">Link to Jupyter notebook</a></p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Automatic differentiation &amp; dual numbers</title><link>http:///automatic-differentiation-dual-numbers.html</link><description><![CDATA["Implementing automatic differentiation in Julia using dual numbers."]]></description><category>programming</category><category>Julia</category><guid>http:///automatic-differentiation-dual-numbers.html</guid><pubDate>Tue, 01 Mar 2022 00:00:00 GMT</pubDate><source url="http://">tag-programming</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p><a href="https://blog.jorisl.nl/media/autodiff/autodiff.html">Link to Jupyter notebook</a></p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item></channel></rss>